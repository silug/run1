#!/usr/bin/perl -w
#
# run1 - Run a program once at a time
#
# LIMITATIONS - Please note that this script will only work reliably
# when the lock directory is on a filesystem (and operating system)
# where you can rely on open() with O_EXCL and flock() working properly.  
# In other words, don't point the lock directory to a network filesystem
# (especially NFS).  Use "-d /some/local/dir".
#
####
#
# Copyright (C) 2001 Steven Pritchard <steve@silug.org>
# This program is free software; you can redistribute it
# and/or modify it under the same terms as Perl itself.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# $Id: run1,v 1.6 2001/06/11 15:46:07 steve Exp $

use strict;

use Getopt::Std;
use FileHandle;
use Fcntl qw(:flock);
use POSIX;# qw(pause :sys_wait_h :errno_h);

use vars qw(%opt $break $debug);
use vars qw($warntime $killtime $lockdir $label $lockfile $lfh $count);

sub debug(@);
sub basename($);

getopts('d:l:w:k:', \%opt);

if (!@ARGV)
{
    print STDERR "usage: " . basename($0) . " <args> [ <arguments> ]\n";
    exit 0;
}

$debug=0;
$debug=1 if (defined($ENV{'DEBUG'}));

$break=0;

if (defined($opt{'w'}))
{
    $warntime=$opt{'w'};
}
else
{
    $warntime=86400; # One day.
}

if (defined($opt{'k'}))
{
    $killtime=$opt{'k'};
}
else
{
    $killtime=0; # Never
}

$lockdir=$opt{'d'} || (getpwuid($<))[7] . "/.locks";

if (!-d $lockdir)
{
    mkdir $lockdir, 0755;
    my $status=$!;
    die "Failed to create $lockdir: $status\n" if (!-d $lockdir);
}

$label=basename($opt{'l'}) || basename($ARGV[0]);
$label=~s/[^\w\.\-]//g;
die "invalid label" if (!$label);
$lockfile="$lockdir/$label";

$count=0;

TRY: $lfh=new FileHandle $lockfile, O_CREAT|O_WRONLY|O_EXCL;

if (!defined($lfh))
{
    if ($!==EEXIST)
    {
	# Either a process is running, or there is a stale pid/lock file.
	$lfh=new FileHandle $lockfile, O_RDWR;
	if (!defined($lfh))
	{
	    if ($!==ENOENT)
	    {
		# The other process probably already exited.
		goto TRY;
	    }
	    else
	    {
		die "Couldn't open lockfile $lockfile: $!\n";
	    }
	}

	sleep 2; # Wait a bit before we try anything.

	my $oldpid=<$lfh>;
	chomp $oldpid;

	if (flock($lfh, LOCK_EX|LOCK_NB))
	{
	    # Got the lock - pid/lock file is stale.
	    print STDERR "Forcing stale lock from process $oldpid.\n";
	    truncate($lfh, 0);
	}
	else
	{
	    # Couldn't get the lock - process must be running.
	    debug "pid $oldpid seems to be running.";
	    my @buf=stat($lfh);
	    if ($killtime && (time>$buf[9]+$killtime))
	    {
		if ($count>10)
		{
		    print STDERR "PID $oldpid won't die!  Giving up...\n";
		    exit 1;
		}
		print STDERR "killing pid $oldpid...\n";
		if (!kill(15, $oldpid))
		{
		    my $status=$!;
		    die "Couldn't kill pid $oldpid: $status\n"
		        if (-d "/proc/$oldpid");
		}
		sleep(2);
		$count++;
		goto TRY;
	    }
	    elsif ($warntime && (time>$buf[9]+$warntime))
	    {
		print STDERR "process $oldpid has been running too long ",
			     "(since ", scalar(localtime($buf[9])), ")\n";
	    }
	    else
	    {
	        debug "pid $oldpid seems to have started ",
		      scalar(localtime($buf[9]));
	    }
	    exit 0;
	}
    }
    else
    {
	die "Couldn't create lockfile $lockfile: $!\n";
    }
}
else
{
    flock($lfh, LOCK_EX|LOCK_NB) or die "Failed to lock $lockfile: $!\n";
}

print $lfh "$$\n";
$lfh->flush;
eval { $lfh->sync }; # This currently (5.6.0) only works on some platforms.
debug "sync() failed on lockfile handle: $@" if ($@);

$SIG{'HUP'}=\&interrupt;
$SIG{'INT'}=\&interrupt;
$SIG{'QUIT'}=\&interrupt;
$SIG{'TERM'}=\&interrupt;
$SIG{'CHLD'}=sub { $break=0; };

my $pid=fork;
if ($pid==-1)
{
    die "fork() failed: $!\n";
}
elsif ($pid==0)
{
    exec @ARGV;
    die "exec() failed: $!\n";
}

while (-d "/proc/$pid")
{
    POSIX::pause;
    kill($break, $pid) if ($break);
    waitpid($pid, &WNOHANG);
}

unlink $lockfile or warn "Failed to unlink $lockfile: $!\n";

sub debug(@)
{
    print STDERR @_, "\n" if ($debug);
}

sub interrupt
{
    ($break)=@_;
}

sub basename($)
{
    my ($arg)=@_;

    return "" if (!$arg);

    my @parts=split '/', $arg;

    return $parts[$#parts];
}

__END__

=head1 NAME

run1 - Run a program once at a time

=head1 SYNOPSIS

B<run1> [ C<-d> I<dir> ] [ C<-l> I<label> ] [ C<-w> I<sec> ] [ C<-k> I<sec> ]
     I<program> [ I<args> ]

=head1 DESCRIPTION

This program is useful for keeping multiple copies of a program from
running concurrently.

=head1 OPTIONS

=over 9

=item C<-d> I<directory>

Save lock/pid files in I<directory> instead of the default (~/.locks).

=item C<-l> I<label>

Use I<label> as the lock/pid file name.  The default is the name of the
program being executed.

=item C<-w> I<seconds>

Print a warning to stderr if the process with the lock has been running
for more than I<seconds> seconds.  The default is 86400 seconds, or one day.
Specifying 0 seconds disables warning messages.

=item C<-k> I<seconds>

Kill the process with the lock if it has been running for more than I<seconds>
seconds.  The default is 0, which disables this feature.

=back

=head1 NOTES

Please note that this script will only work reliably when the lock
directory is on a filesystem (and operating system) where you can rely on
L<open(2)> with C<O_EXCL> and L<flock(2)> working properly.  In other
words, don't point the lock directory to a network filesystem (especially
NFS).  Use C<-d> I</some/local/dir>.

=head1 SEE ALSO

L<lockfile(1)>

=head1 BUGS

The limitations of the locking system (see L<NOTES|"NOTES"> above) could be
construed as bugs.

=head1 AUTHOR

Steven Pritchard E<lt>F<steve@silug.org>E<gt>

=cut
